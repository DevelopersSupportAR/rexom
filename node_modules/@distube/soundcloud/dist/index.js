"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SoundCloudPlugin = void 0;
const soundcloud_ts_1 = __importDefault(require("soundcloud.ts"));
const distube_1 = require("distube");
const sc = new soundcloud_ts_1.default();
const chunker = (arr, size) => {
    const chunks = [];
    let i = 0;
    while (i < arr.length)
        chunks.push(arr.slice(i, (i += size)));
    return chunks;
};
const resolveTracks = async (tracks) => {
    const unsolved = tracks.splice(tracks.findIndex(t => !t.title));
    const chunks = chunker(unsolved, 50);
    const promises = chunks.map(ts => sc.api.getV2("/tracks", { ids: ts.map(t => t.id).join(",") }));
    const solvedTracks = await Promise.all(promises);
    return tracks.concat(solvedTracks.flat());
};
class SoundCloudPlugin extends distube_1.ExtractorPlugin {
    /**
     * Search for tracks/playlists on SoundCloud
     * @param {string} query String query
     * @param {'track'|'playlist'} [type='track'] type
     * @param {number} [limit=10] limit
     * @returns {Array<Song|Playlist>}
     */
    static async search(query, type = "track", limit = 10) {
        var _a;
        if (typeof query !== "string")
            throw new TypeError("query must be a string");
        if (!["track", "playlist"].includes(type))
            throw new TypeError("type must be 'track' or 'playlist'");
        if (typeof limit !== "number" || limit < 1 || Math.floor(limit) !== limit) {
            throw new TypeError("limit must be a natural number");
        }
        if (type === "track") {
            // TODO: Remove any after `soundcloud.ts` fixed the types problem
            const data = await sc.tracks.searchV2({ q: query, limit });
            if (!((_a = data === null || data === void 0 ? void 0 : data.collection) === null || _a === void 0 ? void 0 : _a.length))
                throw new Error("Cannot find any result!");
            return data.collection.map(t => new distube_1.Song(new SoundCloudTrack(t)));
        }
        // TODO: Remove any after `soundcloud.ts` fixed the types problem
        const data = await sc.playlists.searchV2({ q: query, limit });
        const playlists = data.collection;
        return Promise.all(playlists.map(async (p) => {
            var _a;
            const playlist = new SoundCloudPlaylist(p);
            if (!((_a = playlist.tracks) === null || _a === void 0 ? void 0 : _a.length))
                return;
            playlist.songs = (await resolveTracks(playlist.tracks)).map(s => new distube_1.Song(new SoundCloudTrack(s)));
            // eslint-disable-next-line consistent-return
            return new distube_1.Playlist(playlist);
        }));
    }
    /**
     * Search for tracks/playlists on SoundCloud
     * @param {string} query String query
     * @param {'track'|'playlist'} [type='track'] type
     * @param {number} [limit=10] limit
     * @returns {Array<Song|Playlist>}
     */
    search(query, type = "track", limit = 10) {
        return SoundCloudPlugin.search(query, type, limit);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async validate(url) {
        return /^https?:\/\/(?:(?:www|m)\.)?soundcloud\.com\/(.*)$/.test(url);
    }
    async resolve(url, member) {
        var _a;
        url = url.replace(/:\/\/(m|www)\./g, "://");
        const data = await sc.resolve.getV2(url, true).catch(() => undefined);
        if (!data || !["track", "playlist"].includes(data.kind)) {
            throw Error("[SoundCloudPlugin] This link is not supported. It must be a public track or playlist link.");
        }
        if (data.kind === "playlist") {
            const playlist = new SoundCloudPlaylist(data);
            if (!((_a = playlist.tracks) === null || _a === void 0 ? void 0 : _a.length))
                throw Error("[SoundCloudPlugin] The playlist is empty!");
            playlist.songs = (await resolveTracks(playlist.tracks)).map(s => new distube_1.Song(new SoundCloudTrack(s), member, "soundcloud"));
            return new distube_1.Playlist(playlist, member);
        }
        else {
            return new distube_1.Song(new SoundCloudTrack(data), member);
        }
    }
    async getRelatedSongs(url) {
        const related = await sc.tracks.relatedV2(url, 10);
        return related.filter(t => t.title).map(t => new distube_1.Song(new SoundCloudTrack(t)));
    }
    getStreamURL(url) {
        return sc.util.streamLink(url);
    }
}
exports.SoundCloudPlugin = SoundCloudPlugin;
class SoundCloudTrack {
    constructor(info) {
        var _a, _b;
        this.src = "soundcloud";
        this.id = info.id.toString();
        this.name = info.title;
        this.url = info.permalink_url;
        this.thumbnail = info.artwork_url;
        this.duration = info.duration / 1000;
        this.views = info.playback_count;
        this.reposts = info.reposts_count;
        this.uploader = (_a = info.user) === null || _a === void 0 ? void 0 : _a.username;
        this.uploader_url = (_b = info.user) === null || _b === void 0 ? void 0 : _b.permalink_url;
    }
}
class SoundCloudPlaylist {
    constructor(info) {
        var _a;
        this.source = "soundcloud";
        this.id = info.id;
        this.name = info.title;
        this.url = info.permalink_url;
        this.thumbnail = (_a = info.artwork_url) !== null && _a !== void 0 ? _a : undefined;
        this.tracks = info.tracks;
    }
}
exports.default = SoundCloudPlugin;
//# sourceMappingURL=index.js.map